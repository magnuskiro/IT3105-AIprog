\documentclass[titlepage]{article}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}

\author{Jan Alexander Bremnes\\Magnus Kir√∏}
\title{IT3105 - Ex 1\\Texas Hold'em}
\date{September 2011}

\begin{document}

    \maketitle

    \tableofcontents
    \newpage

\section*{TODO}
\begin{itemize}
\item   Integrate modules for hand strength calculation, so that the players can use the information to influence betting behaviour
\item   Change getAction in strategy to use the pre flop rollout-table
\item   CODE ERROR!! in playpoker line #178 change to remainingplayers
\item   Do 5 test runs of 1000 games to produce statistics and update this report
\item   Start looking at opponent modelling!
\section*{Introduction}
This is all about craeting Texas Hold'em bots and making them smart.

\section*{Point distribution and teask completion}
\begin{itemize}
\item A well-functioning Phase I player that obeys all fundamental poker rules. (20 points)

\item Five different 1000-hand runs of a game involving 4 or more Phase-I players, with the results of each 1000-game segment summarized in a table showing the final resource (e.g. money) of each player. (5 points)

\item Modules for computing, storing (to file) and loading (for use in a poker game) the pre-flop rollout probabilities for k = 2 to 10 player games. Each rollout for each card equivalence class should involve at least 1000 rounds of simulated play. (20 points)

\item Modules for estimating hand strength for a pair of hole cards plus 3, 4 or 5 community/shared cards. This will involve testing the given hand against hands made from all possible pairs of hole cards (using the remaining 47 to 45 cards), as described in ai-poker-players.pdf and diagramed in Figure 15 of that document. (15 points)

\item Five different 1000-hand runs of a game involving 4 or more Phase-II players, with the results of each 1000-game segment summarized in a table, as above. (10 points)

\item Modules for performing basic opponent modeling. (15 points)

\item Five different 1000-hand runs of 4 or more players, at least of 2 of which use Phase-III techniques, while the others may use only Phase-II methods. Include the standard summary table of each 1000-game segment. (10 points)

\item The general quality of the report, which must cover all of the 5 topics mentioned above. (5 points).
\end{itemize}

\section*{Report Requirements}
\begin{itemize}
\item The basic structure of your code for each project phase,

\item The logic behind the betting decisions made by the players in each of the project phases that you complete,

\item The opponent models used in phase III, in particular, the contexts used to differentiate game situations,

\item The results of multi-hand (1000) runs for each of the project phases that you complete. These should not be screen dumps, but simple tables indicating each players total winnings. Five simple tables per project phase is all that is required (and desired) here.

\item A brief discussion of why (you believe) certain strategies were more (or less) effective than others for
each phase of the project
\end{itemize}

\pagenumbering{arabic}
\newpage

\section{Introduction}
	This report describes our work done in exercise 1 of IT1305, which were to program a poker bot. We decided to write the program in Python, since then we would not have to bother translating the supplied helper code into another language. This caused some minor problems and annoyances, as neither of us were very familiar with the Python language, having only used it to code algorithms in TDT4160. Being an interpreted language, it runs a great deal slower than compiled languages such as Java and C/C++, so a phase 2 or 3 game consisting of hundreds of hands takes quite some time to run. Because of this, we limited the number of hands played in order to model the players, to 1000, with 10 players in each hand. The preflop rollout-table were calculated from a game with 40,000 hands, which took over 10 hours to simulate on a desktop computer with an Intel Core-i3. Not every single rule of Texas Hold'em is implemented, but where there are rules that are not followed properly, the text will say so. 
	
\section{Code Structure}
	\subsection{Phase 1}
	    Phase 1 consists of a basic simulator for a k-player Texas Hold'Em, with k ranging from 2-10. No players are ever given the role as dealer, that is handled by the central play-poker module. Which of the players are given the role of small blind and big blind, is decided by randomly shuffling the list of players at the start of each hand and choosing the first player in the list as small blind and the second player as big blind. This does not guarantee that a player will have to wait for the blinds to go an entire round before finding himself in the role as small blind again, he may be small blind only two hands after last time, even though there are eight players in the game. We don't consider this to be of any noticable importance
		new-game.py starts the program, and let's the user choose between playing poker, do a test run, or debug. Debugging runs the program with the chosen number of players and rounds, and the game information is printed to screen. As we have not implemented support for human vs computer players, the choice between debugging and play game is a false one, both of them do the same thing. The only difference between play-poker.py and run-test.py, is that play-poker prints gameplay information, while run-test.py only prints the final results after having gone through the chosen number of rounds. Each game creates a list of player-objects, which are given a strategy, a player number, to keep track of who's who, and an initial amount of money. A table-object keeps track of the community cards, the amount of money in the pot, and the current bet. The game-state-object stores the players and table objects to allow easier passing of information between the different parts of the program. Every player has a strategy object, which it uses to decide on betting actions. The file strategy.py can be edited to change the existing strategies or add more. When a player is required to perform an action, the method evaluate-hand, in the module betting.py. is called and depending on the strength of the hand, and the players strategy, the player either folds, calls/checks or raises. The players uses the cards.py module to calculate the strength of their hands. In the pre-flop betting round, these are the only modules that are used. The moduels card.py is the helper code which was supplied to us, with a minor change added so that it's possible to remove cards from a card deck.
		
	\subsection{Phase 2}
		For this phase of the project, we added readPreFlopRollouts.py to let the players decide which equivalence class their hand belongs to, and find the probability of it winning in the rollout-table. To calculate the probabilities after the flop, handstrength.py is used. This module calculates the probability of the players hand, when supplied with the hole cards, the community cards and the number of remaining players. It uses the formula described in ai-poker-players.pdf. The rollout-table is generated with the help of roll-out*.py where * = [1-3]. These modules simulate thousands of games for every possible combination of hole cards, and we use three different modules because we thought it easier to just let the three run simultaneously on a multi core computer, rather than rewriting the code to use threads. The resulting file is then read by scanner.py, which counts the numbers of wins, losses and draws for every equivalence class and calculates the winning probabilities, which are stored in results.txt
		
    \subsection{Phase 3}
        In phase 3, functionality for creating context/action pairs, and analyzing these to create player models, were added. The information gathering was added to the play-poker.py module, and the resulting output was copied to a text file called contexts.txt. This file was analyzed by model-opponents.py and the resulting player models were stored in models.txt. The strategy.py module was updated to allow strategies to incorporate the models. 

\section{Where we explain the logic behind the betting decisions}
	The poker players have different strategies for betting in each of the project phases. They differ from phase to phase, as the amount of information available to the players increase. Phase 1 has three different strategies; conservative, normal and aggressive. In Phase 2 and 3, we included a player that often bluffs.
	
	\subsection{Phase 1 - Primitive strategies, based on randomness and power ratings}
		WARNING! INFORMATION MAY NOT BE CORRECT! CONSULT THE STRATEGY.PY TO SEE HOW THE 	STRATEGIES WORK
In this phase, we made three different player strategies. These strategies are pretty basic, since the only information available to the players are one's own hand strength. In the pre-flop round, betting behaviour is decided by weighted randomness. A conservative player will fold more often than an aggressive player, and an aggressive player will raise more often than a normal player, etc. Post-flop, the behaviour is determined solely by the power rating of the player performing the action. The conservative player folds when his power rating is lower than 4, calls on 5 & 6 and raises with a power rating of 7 or more. The normal player folds with a power rating less than 3, calls on 4 & 5, raise on 6 or greater. The aggressive player only folds on a power rating of 1, calls on 2 & 3, and raises on 4 or greater. 
	
	\subsection{Phase 2 - Strategies based on pre-flop roll-outs and hand strengths}
	    This phase of the project, required the calculation of a preflop rollout-table, and adding a hand strength calculator, both of which the Phase 2 players use to influence betting behaviour. The rollout-table is used prior the the flop, and the hand strength calculator is used in the remaining stages of the hand. We used the results from a simulation of 40,000 games for all numbers of opponents and all possible equivalence classes, to calculate the rollut-table. In the pre-flop betting round, the player finds it's hole cards in the table, retrives the probability of winning the hand and calculates the expected probability for each player. We arrived at this formula by saying that if you're an bystander, not knowing the hole cards of any of the players, then with the information you have, each player has equal probability of winning the hand. Each players probability, in percent, would be p = 100/no.players. When the player calculates its probability of winning the hand, it compares this to p, and will perform an action, which is determined by the players strategy, and if the players probability is equal, larger or smaller than p. A normal player, for example, will raise if it's probability is equal to or larger than p, and fold if it's less than p/2. Aggressive players add an offset of 5-(potodds/2) to their probabilites, and conservative players subtract this same offset. In addition the the three player classes, we added a bluffer-class, which behaves as a regular player, but when a certain game state is reached, it will start bluffing. When a player bluffs, it calls or raises all the way to showdown. 
		
	\subsection{Phase 3 - Strategies that include opponent modelling}
		Phase 3 players use the same rules as Phase 2 players, but they also take into account the estimated hand strenghts of their opponents. These estimations are retrieved from the player models, which are stored as a text file that is loaded into memory when the program starts. The player models were generated from the context/action-pairs gathered over a 1000-hand, 10-players game. See BLBLALA.txt and LEOIAKL.txt
		
\section{The Opponent Modeling}
    In phase 3 we implemented functionality for basic opponent modeling. Every player object has a dictionary used to store context/action-pairs in. For every action a player performs, a new context/action pair is stored in that players dictionary. When the hand is finished, the context/action-pairs of players that have folded are discarded, and those who made it to showdown are analyzed. For every context/action-pair of the current hand, the players hand strength, at the time of play when the context was recorded, is calculated and stored in a second dictionary in the respective player object. The use of dictionaries ensures that only unique context/action-pairs are stored; the context/action pairs are used as the key, and the list of hand strengths as the value. The player models are stored in a text file, and is loaded into memory when the game starts. The player models were generated from the context/action-pairs gathered over a 1000-hand, 10-players game, in which all the players were given a Phase 2 strategy. When used in Phase 3 to compare strategies from all three phases, no models for Phase 1 players are used, as they do not exist. The game information used to define a context is the betting round (pre-flop = 1, post-flop = 2 ... ), how many players remain, and the pot odds. This is the only information used by the players to decide their behaviour, so using more information to define the context, such as number of raises, will create more contexts, and less useful player models. 
		
		
\section{Remarks}
    When there is a draw, and the pot is split between players, if the pot is not a multiple of the number of players it is split between, the total amount of money in the game will decrease. For example, if there are three winners, and the pot is 3002, then each player will win 1000, and the amount of money in play is reduced with 2. Because of this, there will sometimes be a small difference between the total amount the players started with, and the total amount they end up with.
    		
\section{Future work}
	Players strategies can be improved by letting them take more information about the game state into account. The current strategies only use the information about the players themselves. They do not take into consideration all the other information that is present, such as number of remaining players, how big the current pot is and how hight the current bet is. If a player has a mediocre hand, there's only two remaining opponents out of the original seven, and the current bet is a small fraction of the players current money, then it would make more sense to place a bet, or raise, then it would if there were seven opponents and a bet a quarter of the players money.

\section{Player winnings tables}
	\subsection{Phase-1 player winnings table}
		5-players, 1000-games, 100-start money \\
		\begin{matrix}
		  	\\
			game set:    &     1  &     2  &     3 &     4 &     5 \\
			Player 0 & -4600  &   850  & -2290 &  1970 &  3730 \\
			Player 1 & -3430  &  2590  &  1690 &   280 &   580 \\
			Player 2 &  1520  &  2980  &  1100 &  -390 &  4390 \\
			Player 3 &  -120  & -1300  &  -350 & -1930 & -5390 \\
			Player 4 &  7130  & -4620  &   350 &   570 & -2810 \\
		\end{matrix}

	\subsection{Phase-2 player winnings table}
		5-players, 1000-games, 100-start money \\
		\begin{matrix}
			\\
			game set:    &     1  &     2  &     3 &     4 &     5 \\
			Player 0 & -4600  &   850  & -2290 &  1970 &  3730 \\
			Player 1 & -3430  &  2590  &  1690 &   280 &   580 \\
			Player 2 &  1520  &  2980  &  1100 &  -390 &  4390 \\
			Player 3 &  -120  & -1300  &  -350 & -1930 & -5390 \\
			Player 4 &  7130  & -4620  &   350 &   570 & -2810 \\
		\end{matrix}
		
	\subsection{Phase-3 player winnings table}
		5-players, 1000-games, 100-start money \\
		\begin{matrix}
			\\
			game set:    &     1  &     2  &     3 &     4 &     5 \\
			Player 0 & -4600  &   850  & -2290 &  1970 &  3730 \\
			Player 1 & -3430  &  2590  &  1690 &   280 &   580 \\
			Player 2 &  1520  &  2980  &  1100 &  -390 &  4390 \\
			Player 3 &  -120  & -1300  &  -350 & -1930 & -5390 \\
			Player 4 &  7130  & -4620  &   350 &   570 & -2810 \\
		\end{matrix}



\end{document}
